"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

exports.__esModule = true;
exports.popCopy = popCopy;
exports.filesToCopy = exports.fileCopy = exports.fileShouldCopy = exports.cache = void 0;

require("core-js/modules/esnext.map.delete-all.js");

require("core-js/modules/esnext.map.every.js");

require("core-js/modules/esnext.map.filter.js");

require("core-js/modules/esnext.map.find.js");

require("core-js/modules/esnext.map.find-key.js");

require("core-js/modules/esnext.map.includes.js");

require("core-js/modules/esnext.map.key-of.js");

require("core-js/modules/esnext.map.map-keys.js");

require("core-js/modules/esnext.map.map-values.js");

require("core-js/modules/esnext.map.merge.js");

require("core-js/modules/esnext.map.reduce.js");

require("core-js/modules/esnext.map.some.js");

require("core-js/modules/esnext.map.update.js");

var _path = _interopRequireDefault(require("path"));

var _wtf = _interopRequireDefault(require("@nodeproto/wtf"));

const {
  fs
} = _wtf.default;
const cache = new Map();
exports.cache = cache;

const fileShouldCopy = async sourcepath => {
  let fd;

  try {
    fd = await fs.open(sourcepath, 'r');
    if (!fd) return;
    const {
      mtimeMs
    } = await fd.stat();
    const cacheMs = cache.get(sourcepath)?.ms;
    fd.close();
    return (!cacheMs || cacheMs < mtimeMs) && mtimeMs;
  } catch (e) {
    console.warn('error accessing file, removing from cache\n', {
      sourcepath,
      e
    });
    fd?.close();
    cache.delete(sourcepath);
    return false;
  }
};

exports.fileShouldCopy = fileShouldCopy;

const fileCopy = async (newCacheMs, sourcepath, outdir) => {
  try {
    if (newCacheMs) {
      const outpath = `${outdir}/${_path.default.basename(sourcepath)}`;
      cache.set(sourcepath, {
        ms: newCacheMs,
        outpath
      });
      await fs.mkdir(outdir, {
        recursive: true
      });
      await fs.copyFile(sourcepath, outpath);
    }
  } catch (e) {
    cache.delete(sourcepath);
    console.warn('\n\n error copying file into outdir', {
      sourcepath,
      e
    });
  }
};

exports.fileCopy = fileCopy;

const filesToCopy = options => {
  const msg = 'not copying files:';

  if (!options.length) {
    return console.warn(`${msg} options empty`, options);
  }

  options.forEach(async ({
    outdir,
    endingWith,
    indir,
    recurse,
    ...opts
  }) => {
    try {
      if (!(endingWith instanceof RegExp) || !indir || !indir.startsWith('/') || !outdir || !outdir.startsWith('/')) {
        return console.warn(`${msg} invalid params`, {
          outdir,
          endingWith,
          indir,
          recurse,
          opts
        });
      }

      const sourcedirs = (await fs.readdir(indir, {
        encoding: 'utf8',
        withFileTypes: true
      })) ?? [];
      sourcedirs.forEach(dirEnt => {
        if (!dirEnt.name.includes('.') && recurse) {
          filesToCopy([{
            outdir,
            endingWith,
            recurse,
            indir: `${indir}/${dirEnt.name}`,
            ...opts
          }]);
        } else {
          if (endingWith.test(dirEnt.name)) {
            const sourcepath = `${indir}/${dirEnt.name}`;
            const outpath = `${outdir}/${dirEnt.name}`;
            cache.set(sourcepath, {
              ms: null,
              outpath
            });
          }
        }
      });
    } catch (e) {
      console.error('\n\n error in popcopy', e);
    }
  });
};

exports.filesToCopy = filesToCopy;
const name = 'popCopyPlugin';

function popCopy(config) {
  popCopy.options = config;
  popCopy.onStarted = false;
  return {
    name,

    setup(build) {
      const {
        options
      } = popCopy.options ?? {};
      if (!options) return;
      filesToCopy(options);
      build.onResolve({
        filter: /^popcopy$/
      }, () => ({}));
      build.onStart(async () => {
        if (popCopy.onStarted) return;
        popCopy.onStarted = true;

        if (cache.size) {
          for (const [sourcepath, {
            ms,
            outpath
          }] of cache) {
            try {
              const newCacheMs = await fileShouldCopy(sourcepath);

              if (newCacheMs) {
                await fileCopy(newCacheMs, sourcepath, _path.default.dirname(outpath));
              }
            } catch (e) {
              console.warn('popCopy.onStart error', e);
            }
          }
        }
      });
      build.onEnd(result => {
        popCopy.onStarted = false;
      });
    }

  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzYnVpbGQvcGx1Z2lucy9wb3BDb3B5LmVzYnVpbGQucGx1Z2luLm1qcyJdLCJuYW1lcyI6WyJmcyIsInd0ZiIsImNhY2hlIiwiTWFwIiwiZmlsZVNob3VsZENvcHkiLCJzb3VyY2VwYXRoIiwiZmQiLCJvcGVuIiwibXRpbWVNcyIsInN0YXQiLCJjYWNoZU1zIiwiZ2V0IiwibXMiLCJjbG9zZSIsImUiLCJjb25zb2xlIiwid2FybiIsImRlbGV0ZSIsImZpbGVDb3B5IiwibmV3Q2FjaGVNcyIsIm91dGRpciIsIm91dHBhdGgiLCJwYXRoIiwiYmFzZW5hbWUiLCJzZXQiLCJta2RpciIsInJlY3Vyc2l2ZSIsImNvcHlGaWxlIiwiZmlsZXNUb0NvcHkiLCJvcHRpb25zIiwibXNnIiwibGVuZ3RoIiwiZm9yRWFjaCIsImVuZGluZ1dpdGgiLCJpbmRpciIsInJlY3Vyc2UiLCJvcHRzIiwiUmVnRXhwIiwic3RhcnRzV2l0aCIsInNvdXJjZWRpcnMiLCJyZWFkZGlyIiwiZW5jb2RpbmciLCJ3aXRoRmlsZVR5cGVzIiwiZGlyRW50IiwibmFtZSIsImluY2x1ZGVzIiwidGVzdCIsImVycm9yIiwicG9wQ29weSIsImNvbmZpZyIsIm9uU3RhcnRlZCIsInNldHVwIiwiYnVpbGQiLCJvblJlc29sdmUiLCJmaWx0ZXIiLCJvblN0YXJ0Iiwic2l6ZSIsImRpcm5hbWUiLCJvbkVuZCIsInJlc3VsdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVlBOztBQUNBOztBQUVBLE1BQU07QUFBRUEsRUFBQUE7QUFBRixJQUFTQyxZQUFmO0FBS08sTUFBTUMsS0FBSyxHQUFHLElBQUlDLEdBQUosRUFBZDs7O0FBR0EsTUFBTUMsY0FBYyxHQUFHLE1BQU1DLFVBQU4sSUFBb0I7QUFDaEQsTUFBSUMsRUFBSjs7QUFDQSxNQUFJO0FBQ0ZBLElBQUFBLEVBQUUsR0FBRyxNQUFNTixFQUFFLENBQUNPLElBQUgsQ0FDVEYsVUFEUyxFQUVULEdB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QUZEO0FBR0Q7O0FBaEVJLEdBQVA7QUFrRUQiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQHNlZSBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PXpSN0xPdE1peDl3XG4gKlxuICogcG9wQ29weSBlc2J1aWxkIHBsdWdpblxuICogY29waWVzIGZpbGVzIHN5bmNocm9ub3VzbHkgYmVmb3JlIEVBQ0ggYnVpbGQgaW50byB0aGUgb3V0cHV0IGRpcmVjdG9yeVxuICogY2FjaGVzIHJlc3VsdHM6IGluY3JlbWVudGFsIGJ1aWxkcyA+IHRoYW4gaW5pdGlhbFxuICpcbiAqIFRPRE86IGh0dHBzOi8vZXNidWlsZC5naXRodWIuaW8vYXBpLyNpbmNyZW1lbnRhbFxuICogaW1wbGVtZW50IHdhdGNoaW5nIHlhbWwgZmlsZXNcbiAqL1xuXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB3dGYgZnJvbSAnQG5vZGVwcm90by93dGYnO1xuXG5jb25zdCB7IGZzIH0gPSB3dGY7XG4vLyBjYWNoZSBtYXBwaW5nIHsgZmlsZXBhdGg6IHsgaW5wdXQsIG91dHB1dH0gfVxuLy8gZm9yIHVzIHRvIHJldHVybiB0aGUgcHJldmlvdXMgb3V0cHV0IGlmIHRoZSBpbnB1dCBoYXNudCBjaGFuZ2Vcbi8vIEFMV0FZUyB1c2UgdGhlIGZpbGVwYXRoIGFzIGtleVxuLy8gQHNlZSBodHRwczovL2VzYnVpbGQuZ2l0aHViLmlvL3BsdWdpbnMvI2NhY2hpbmcteW91ci1wbHVnaW5cbmV4cG9ydCBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcblxuLy8gZmlsZVNob3VsZENvcHkocGF0aCkgPT4gbGFzdE1vZGlmaWVkIGluIE1TIG9yIHVuZGVmaW5lZFxuZXhwb3J0IGNvbnN0IGZpbGVTaG91bGRDb3B5ID0gYXN5bmMgc291cmNlcGF0aCA9PiB7XG4gIGxldCBmZDtcbiAgdHJ5IHtcbiAgICBmZCA9IGF3YWl0IGZzLm9wZW4oXG4gICAgICBzb3VyY2VwYXRoLFxuICAgICAgJ3InXG4gICAgKTtcbiAgICBpZiAoIWZkKSByZXR1cm47XG5cbiAgICBjb25zdCB7IG10aW1lTXMgfSA9IGF3YWl0IGZkLnN0YXQoKTtcbiAgICBjb25zdCBjYWNoZU1zID0gY2FjaGUuZ2V0KHNvdXJjZXBhdGgpPy5tcztcbiAgICBmZC5jbG9zZSgpO1xuICAgIHJldHVybiAoIWNhY2hlTXMgfHwgKGNhY2hlTXMgPCBtdGltZU1zKSkgJiYgbXRpbWVNc1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ2Vycm9yIGFjY2Vzc2luZyBmaWxlLCByZW1vdmluZyBmcm9tIGNhY2hlXFxuJyxcbiAgICAgIHsgc291cmNlcGF0aCwgZSB9XG4gICAgKTtcbiAgICBmZD8uY2xvc2UoKTtcbiAgICBjYWNoZS5kZWxldGUoc291cmNlcGF0aCk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIGNvcHkgZmlsZSBpbnRvIHNwZWNpZmllZCBvdXRkaXIgJiYgY2FjaGVzIGZpbGUgdGltZSBpbiBtc1xuZXhwb3J0IGNvbnN0IGZpbGVDb3B5ID0gYXN5bmMgKG5ld0NhY2hlTXMsIHNvdXJjZXBhdGgsIG91dGRpcikgPT4ge1xuICB0cnkge1xuICAgIGlmIChuZXdDYWNoZU1zKSB7XG4gICAgICBjb25zdCBvdXRwYXRoID0gYCR7b3V0ZGlyfS8ke3BhdGguYmFzZW5hbWUoc291cmNlcGF0aCl9YDtcbiAgICAgIGNhY2hlLnNldChcbiAgICAgICAgc291cmNlcGF0aCxcbiAgICAgICAgeyBtczogbmV3Q2FjaGVNcywgb3V0cGF0aCB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBmcy5ta2RpcihcbiAgICAgICAgb3V0ZGlyLFxuICAgICAgICB7IHJlY3Vyc2l2ZTogdHJ1ZSB9XG4gICAgICApXG4gICAgICBhd2FpdCBmcy5jb3B5RmlsZShcbiAgICAgICAgc291cmNlcGF0aCxcbiAgICAgICAgb3V0cGF0aFxuICAgICAgKTsgLy8gZG9udCBjYXRjaCBsZXQgaXQgdGhyb3dcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZS5kZWxldGUoc291cmNlcGF0aCk7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1xcblxcbiBlcnJvciBjb3B5aW5nIGZpbGUgaW50byBvdXRkaXInLFxuICAgICAgeyBzb3VyY2VwYXRoLCBlIH1cbiAgICApO1xuICB9XG59O1xuXG4vLyBzZWFyY2hlcyBmb3IgZmlsZXMgdG8gY29weVxuLy8gc2V0cyBmaWxlcGF0aHMgYXMga2V5cyBpbiBjYWNoZVxuZXhwb3J0IGNvbnN0IGZpbGVzVG9Db3B5ID0gb3B0aW9ucyA9PiB7XG4gIGNvbnN0IG1zZyA9ICdub3QgY29weWluZyBmaWxlczonO1xuXG4gIGlmICghb3B0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY29uc29sZS53YXJuKFxuYCR7bXNnfSBvcHRpb25zIGVtcHR5YCxcbm9wdGlvbnNcbiAgICApO1xuICB9XG5cbiAgb3B0aW9ucy5mb3JFYWNoKGFzeW5jICh7IG91dGRpciwgZW5kaW5nV2l0aCwgaW5kaXIsIHJlY3Vyc2UsIC4uLm9wdHMgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoXG4gICAgICAgICEoZW5kaW5nV2l0aCBpbnN0YW5jZW9mIFJlZ0V4cCkgfHxcbiAgICAgICAgKCFpbmRpciB8fCAhaW5kaXIuc3RhcnRzV2l0aCgnLycpKSB8fFxuICAgICAgICAoIW91dGRpciB8fCAhb3V0ZGlyLnN0YXJ0c1dpdGgoJy8nKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFxuICAgICAgICBgJHttc2d9IGludmFsaWQgcGFyYW1zYCxcbiAgICAgICAgeyBvdXRkaXIsIGVuZGluZ1dpdGgsIGluZGlyLCByZWN1cnNlLCBvcHRzIH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc291cmNlZGlycyA9IGF3YWl0IGZzLnJlYWRkaXIoXG4gICAgICAgIGluZGlyLFxuICAgICAgICB7IGVuY29kaW5nOiAndXRmOCcsIHdpdGhGaWxlVHlwZXM6IHRydWUgfVxuICAgICAgKSA/PyBbXTtcblxuICAgICAgc291cmNlZGlycy5mb3JFYWNoKGRpckVudCA9PiB7XG4gICAgICAgIC8vIGNoZWNrIGFsbCBjaGlsZC1kaXJzXG4gICAgICAgIC8vIG5lZWQgdG8gY2hlY2sgZGlyRW50W3N5bWJvbF0gdHlwZSA9PT0gMlxuICAgICAgICAvLyBiZWNhdXNlIGR1aCBmaWxlcyB3aXRob3V0IGV4dGVuc2lvbnNcbiAgICAgICAgaWYgKCFkaXJFbnQubmFtZS5pbmNsdWRlcygnLicpICYmIHJlY3Vyc2UpIHtcbiAgICAgICAgICBmaWxlc1RvQ29weShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dGRpcixcbiAgICAgICAgICAgICAgZW5kaW5nV2l0aCxcbiAgICAgICAgICAgICAgcmVjdXJzZSxcbiAgICAgICAgICAgICAgaW5kaXI6IGAke2luZGlyfS8ke2RpckVudC5uYW1lfWAsXG4gICAgICAgICAgICAgIC4uLm9wdHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiBmaWxlbmFtZSBlbmRzV2l0aCByZWdleFxuICAgICAgICAgIGlmIChlbmRpbmdXaXRoLnRlc3QoZGlyRW50Lm5hbWUpKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBmaWxlcyBzaG91bGQgYmUgY29waWVkXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VwYXRoID0gYCR7aW5kaXJ9LyR7ZGlyRW50Lm5hbWV9YDtcbiAgICAgICAgICAgIGNvbnN0IG91dHBhdGggPSBgJHtvdXRkaXJ9LyR7ZGlyRW50Lm5hbWV9YDtcbiAgICAgICAgICAgIGNhY2hlLnNldChcbiAgICAgICAgICAgICAgc291cmNlcGF0aCxcbiAgICAgICAgICAgICAgeyBtczogbnVsbCwgb3V0cGF0aCB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnXFxuXFxuIGVycm9yIGluIHBvcGNvcHknLFxuICAgICAgICBlXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59O1xuXG5jb25zdCBuYW1lID0gJ3BvcENvcHlQbHVnaW4nO1xuXG5leHBvcnQgZnVuY3Rpb24gcG9wQ29weSAoY29uZmlnKSB7XG4gIHBvcENvcHkub3B0aW9ucyA9IGNvbmZpZztcbiAgcG9wQ29weS5vblN0YXJ0ZWQgPSBmYWxzZTtcblxuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgc2V0dXAgKGJ1aWxkKSB7XG4gICAgICAvKipcbiAgICAgICAqIG9wdGlvbnNcbiAgICAgICAqIHsgb3B0aW9uczogW3sgaW5kaXIsIGVuZGluZ1dpdGgsIHJlY3Vyc2UsIG91dGRpciB9XX1cbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiAgICAgICAgICBmaW5kcyBhbGwgZmlsZXMgZW5kaW5nV2l0aCAvb3BlbmFwaVxcLih5bWx8eWFtbCkkL1xuICAgICAgICogICAgICAgICAgYW5kIGNvcGllcyB0aGVtIGludG8gZXNidWlsZC5jb25maWcub3V0ZGlyXG4gICAgICAgKiAgICAgICAgICB7IG9wdGlvbnM6IFt7XG4gICAgICAgKiAgICAgICAgICAgICAgaW5kaXI6ICcvYWJzb2x1dGUvcGF0aCcsXG4gICAgICAgKiAgICAgICAgICAgICAgb3V0ZGlyOiAvYWJzb2x1dGUvcGF0aCdcbiAgICAgICAqICAgICAgICAgICAgICBlbmRpbmdXaXRoOiAvb3BlbmFwaVxcLih5bWx8eWFtbCkkLyxcbiAgICAgICAqICAgICAgICAgICAgICByZWN1cnNlOiB0cnVlLFxuICAgICAgICogICAgICAgICAgfV19XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gcG9wQ29weS5vcHRpb25zID8/IHt9O1xuICAgICAgaWYgKCFvcHRpb25zKSByZXR1cm47XG5cbiAgICAgIC8vIFNURVAgMVxuICAgICAgLy8gcmV0cmlldmUgYXNzZXQgZGlyZWN0b3JpZXMgZnJvbSBvcHRpb25zXG4gICAgICAvLyBzY2FuIGVhY2ggZGlyIGZvciBmaWxlcyBtYXRjaGluZyBwcm92aWRlZCByZWdleFxuICAgICAgLy8gZm9yIGVhY2ggZmlsZSBmb3VuZCBydW4gY2FjaGUuc2V0KGZpbGVQYXRoLCB1bmRlZmluZWQpXG4gICAgICBmaWxlc1RvQ29weShvcHRpb25zKTtcblxuICAgICAgYnVpbGQub25SZXNvbHZlKFxuICAgICAgICB7IGZpbHRlcjogL15wb3Bjb3B5JC8gfSxcbiAgICAgICAgKCkgPT4gKHt9KVxuICAgICAgKTtcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9lc2J1aWxkLmdpdGh1Yi5pby9wbHVnaW5zLyNzdGFydC1jYWxsYmFja3NcbiAgICAgIGJ1aWxkLm9uU3RhcnQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAocG9wQ29weS5vblN0YXJ0ZWQpIHJldHVybjtcbiAgICAgICAgcG9wQ29weS5vblN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIFNURVAgMlxuICAgICAgICAvLyBsb29wIGNhY2hlIGFuZCBjb3B5IGZpbGVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAoY2FjaGUuc2l6ZSkge1xuICAgICAgICAgIGZvciAoY29uc3QgW1xuICAgICAgICAgICAgc291cmNlcGF0aCxcbiAgICAgICAgICAgIHsgbXMsIG91dHBhdGggfVxuICAgICAgICAgIF0gb2YgY2FjaGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0NhY2hlTXMgPSBhd2FpdCBmaWxlU2hvdWxkQ29weShzb3VyY2VwYXRoKTtcbiAgICAgICAgICAgICAgaWYgKG5ld0NhY2hlTXMpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmaWxlQ29weShcbiAgICAgICAgICAgICAgICAgIG5ld0NhY2hlTXMsXG4gICAgICAgICAgICAgICAgICBzb3VyY2VwYXRoLFxuICAgICAgICAgICAgICAgICAgcGF0aC5kaXJuYW1lKG91dHBhdGgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgJ3BvcENvcHkub25TdGFydCBlcnJvcicsXG4gICAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9lc2J1aWxkLmdpdGh1Yi5pby9wbHVnaW5zLyNlbmQtY2FsbGJhY2tzXG4gICAgICBidWlsZC5vbkVuZChyZXN1bHQgPT4ge1xuICAgICAgICBwb3BDb3B5Lm9uU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfTtcbn1cbiJdfQ==